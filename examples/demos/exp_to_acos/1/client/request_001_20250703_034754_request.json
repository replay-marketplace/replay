{
  "model": "claude-3-7-sonnet-20250219",
  "system": "You write code. \nAll your responses should be in JSON format. \nDont include the word json before and after with the apostrophies in your response. \nReply with JUST the json. \nYou can edit files in \"code_to_edit\", and you can use the knowledge from \"read_only_files\".\nIf I ask you to generate any commands to be run in the terminal based on the code, \nput the commands in the \"commands_to_run\" field; use python3.\nYou don't need to make new directories for files you generate, they will automatically get created. \nKeep in mind \"memory\" records from previous interactions.\nAppend concise summary of your response to the \"memory\" array. \nDo not remove items from the memory without being explicitly asked to do so.\nDo not assume that your current action is successful until confirmed that a check was successful.\nDo not write \"fixed\" or \"resolved\". I will call tests to verify if suggested change works.\nKeep memory entries focused. Include any new facts you learned from our interaction.\n{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$id\": \"https://example.com/project-structure.schema.json\",\n    \"title\": \"Project Structure\",\n    \"description\": \"Schema for a project containing files and commands to run\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"files\": {\n        \"type\": \"array\",\n        \"description\": \"Array of files to be created in the project\",\n        \"items\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"path_and_filename\": {\n              \"type\": \"string\",\n              \"description\": \"The file path and filename relative to the project root\",\n              \"minLength\": 1\n            },\n            \"contents\": {\n              \"type\": \"string\",\n              \"description\": \"The contents of the file\"\n            }\n          },\n          \"required\": [\"path_and_filename\", \"contents\"],\n          \"additionalProperties\": false\n        },\n        \"minItems\": 1\n      },      \n      \"commands_to_run\": {\n        \"type\": \"array\",\n        \"description\": \"Array of shell commands to execute\",\n        \"items\": {\n          \"type\": \"string\",\n          \"description\": \"A shell command to execute\",\n          \"minLength\": 1\n        }\n      },\n      \"memory\": {\n        \"type\": \"array\",\n        \"description\": \"Interaction memory\",\n        \"items\": {\n          \"type\": \"string\",\n          \"description\": \"Concise summary of actions taken or decisions made\",\n          \"minLength\": 1,\n          \"maxLength\": 200\n        }\n      },\n    },\n    \"required\": [\"files\", \"memory\"],\n    \"additionalProperties\": false\n  }\n",
  "messages": [
    {
      "role": "user",
      "content": "{\n  \"prompt\": \"Update @code:tt_eltwise_sfpu.cpp to implement acos operation instead of exp Update @code:test_newop.py to compare against ttnn.acos instead of exp Reference @docs:kernel_api_compute_operations.md for API Reference If you use any compute APIs include \\\"compute_kernel_api.h\\\" header\",\n  \"code_to_edit\": [\n    {\n      \"path_and_filename\": \"tt_eltwise_sfpu.cpp\",\n      \"contents\": \"// SPDX-FileCopyrightText: \\u00a9 2023 Tenstorrent Inc.\\n//\\n// SPDX-License-Identifier: Apache-2.0\\n\\n#include <cstdint>\\n#include \\\"compute_kernel_api/common.h\\\"\\n#include \\\"compute_kernel_api/tile_move_copy.h\\\"\\n#include \\\"compute_kernel_api/eltwise_unary/exp.h\\\"\\n#include \\\"compute_kernel_api/eltwise_unary/eltwise_unary.h\\\"\\n#include \\\"compute_kernel_api/eltwise_unary/sfpu_split_includes.h\\\"\\n\\nnamespace NAMESPACE {\\nvoid MAIN {\\n    uint32_t per_core_block_cnt = get_compile_time_arg_val(0);\\n    uint32_t per_core_block_dim = get_compile_time_arg_val(1);\\n\\n    init_sfpu(tt::CBIndex::c_0, tt::CBIndex::c_16);\\n    for (uint32_t block_index = 0; block_index < per_core_block_cnt; block_index++) {\\n        cb_reserve_back(tt::CBIndex::c_16, per_core_block_dim);\\n        for (uint32_t tile_index = 0; tile_index < per_core_block_dim; ++tile_index) {\\n            tile_regs_acquire();\\n\\n            // Pop tile after tile, copy to DST and pack\\n            cb_wait_front(tt::CBIndex::c_0, 1);\\n            copy_tile(tt::CBIndex::c_0, 0, 0);\\n\\n            exp_tile_init(); \\n            exp_tile(0);\\n\\n            tile_regs_commit();\\n            tile_regs_wait();\\n            pack_tile(0, tt::CBIndex::c_16);\\n\\n            cb_pop_front(tt::CBIndex::c_0, 1);\\n            tile_regs_release();\\n        }\\n        cb_push_back(tt::CBIndex::c_16, per_core_block_dim);\\n    }\\n}\\n}  // namespace NAMESPACE\\n\"\n    },\n    {\n      \"path_and_filename\": \"test_newop.py\",\n      \"contents\": \"import torch\\nimport pytest\\nimport ttnn\\nimport numpy as np\\nimport os\\nfrom loguru import logger\\n\\ndef kernel_path(kernel_file_name):    \\n    current_file_path = os.path.abspath(__file__)\\n    current_dir = os.path.dirname(current_file_path)\\n    kernel_dir = current_dir\\n    return os.path.join(kernel_dir, kernel_file_name)\\n\\ndef prepare_newop_program(device, input_tensor, output_tensor, num_tiles, src_bank_id, dst_bank_id):\\n    core = ttnn.CoreCoord(0, 0)\\n    core_grid = ttnn.CoreRangeSet([ttnn.CoreRange(core, core)])\\n\\n    input_cb_data_format = ttnn.bfloat16  # this will be mapped tt::DataFormat::Float16_b\\n    cb_total_size = 2 * 2 * 1024  # tt::DataFormat::Float16_b hard coded to have size 2 * 1024\\n    cb_page_size = 2 * 1024\\n\\n    in_cb = 0\\n    out_cb = 16\\n    in_cb_format = ttnn.CBFormatDescriptor(buffer_index=in_cb, data_format=input_cb_data_format, page_size=cb_page_size,)\\n    out_cb_format = ttnn.CBFormatDescriptor(buffer_index=out_cb, data_format=input_cb_data_format, page_size=cb_page_size,)\\n    in_cb_descriptor = ttnn.CBDescriptor(total_size=cb_total_size,core_ranges=core_grid,format_descriptors=[in_cb_format],)\\n    out_cb_descriptor = ttnn.CBDescriptor(total_size=cb_total_size,core_ranges=core_grid,format_descriptors=[out_cb_format],)\\n\\n    is_dram_input = 1\\n    reader_compile_time_args = [is_dram_input]\\n    writer_compile_time_args = [out_cb, is_dram_input]\\n    compute_compile_time_args = [num_tiles, 1]\\n    reader_rt_args = [input_tensor.buffer_address(), num_tiles, 0]\\n    writer_rt_args = [output_tensor.buffer_address(), num_tiles, 0]\\n\\n\\n    # create a kernel descriptor for the reader kernel\\n    reader_kernel_descriptor = ttnn.KernelDescriptor(\\n        kernel_source=kernel_path(\\\"tt_reader.cpp\\\"),\\n        core_ranges=core_grid,\\n        compile_time_args=reader_compile_time_args,\\n        runtime_args=[[reader_rt_args]],\\n        config=ttnn.ReaderConfigDescriptor(),\\n    )\\n    writer_kernel_descriptor = ttnn.KernelDescriptor(\\n        kernel_source=kernel_path(\\\"tt_writer.cpp\\\"),\\n        core_ranges=core_grid,\\n        compile_time_args=writer_compile_time_args,\\n        runtime_args=[[writer_rt_args]],\\n        config=ttnn.WriterConfigDescriptor(),\\n    )\\n    \\n    compute_kernel_descriptor = ttnn.KernelDescriptor(\\n        kernel_source=kernel_path(\\\"tt_eltwise_sfpu.cpp\\\"),\\n        core_ranges=core_grid,\\n        compile_time_args=compute_compile_time_args,\\n        defines=[],\\n        runtime_args=[[[]]],\\n        config=ttnn.ComputeConfigDescriptor(),\\n    )\\n\\n    program_descriptor = ttnn.ProgramDescriptor(\\n        kernels=[reader_kernel_descriptor, writer_kernel_descriptor, compute_kernel_descriptor],\\n        semaphores=[],\\n        cbs=[in_cb_descriptor, out_cb_descriptor],\\n    )\\n\\n    return program_descriptor\\n\\ndef test_new_op():\\n    device = ttnn.open_device(device_id=0)\\n\\n    num_tiles = 4\\n    src_bank_id = 0\\n    dst_bank_id = 0\\n\\n    shape = [1, num_tiles, 32, 32]\\n    data = torch.rand(shape).to(torch.bfloat16)\\n\\n    dram_memory_config = ttnn.DRAM_MEMORY_CONFIG\\n\\n    input_tensor = ttnn.from_torch(data, dtype=ttnn.bfloat16, layout=ttnn.TILE_LAYOUT, device=device, memory_config=dram_memory_config)\\n    output_tensor = ttnn.allocate_tensor_on_device(ttnn.Shape(shape), ttnn.bfloat16, ttnn.TILE_LAYOUT, device, dram_memory_config)\\n    \\n    io_tensors = [input_tensor, output_tensor]\\n\\n    program_descriptor = prepare_newop_program(device, input_tensor, output_tensor, num_tiles, src_bank_id, dst_bank_id)\\n\\n    output = ttnn.generic_op(io_tensors, program_descriptor)\\n    golden = ttnn.exp(input_tensor)\\n\\n    torch_golden = ttnn.to_torch(golden)\\n    torch_output = ttnn.to_torch(output)\\n    logger.info(f\\\"input_tensor: {input_tensor}\\\")\\n    logger.info(f\\\"torch_golden: {torch_golden}\\\")\\n    logger.info(f\\\"torch_output: {torch_output}\\\")\\n\\n    matching = torch.allclose(torch_golden, torch_output)\\n    logger.info(f\\\"Tensors are matching: {matching}\\\")\\n    assert matching\\n\\n    ttnn.close_device(device)\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    test_new_op()\"\n    }\n  ],\n  \"read_only_files\": [\n    {\n      \"path_and_filename\": \"kernel_api_compute_operations.md\",\n      \"contents\": \"### Compute Operations\\n#### Compute APIs\\uf0c1\\n\\n  * [copy_tile](copy_tile.html)\\n  * [move_copy_tile](move_copy_tile.html)\\n  * [acquire_dst](acquire_dst.html)\\n  * [release_dst](release_dst.html)\\n  * [reg_api](reg_api.html)\\n  * [any_init](init_functions.html)\\n  * [abs_tile](abs_tile.html)\\n  * [add_tiles](add_tiles.html)\\n  * [sub_tiles](sub_tiles.html)\\n  * [mul_tiles](mul_tiles.html)\\n  * [add_tiles_bcast](add_tiles_bcast.html)\\n  * [sub_tiles_bcast](sub_tiles_bcast.html)\\n  * [mul_tiles_bcast](mul_tiles_bcast.html)\\n  * [matmul_tiles](matmul_tiles.html)\\n  * [matmul_block](matmul_block.html)\\n  * [exp_tile](exp_tile.html)\\n  * [exp2_tile](exp2_tile.html)\\n  * [expm1_tile](expm1_tile.html)\\n  * [relu_tile](relu_tile.html)\\n  * [relu_max_tile](relu_tile.html#relu-max-tile)\\n  * [relu_min_tile](relu_tile.html#relu-min-tile)\\n  * [leaky_relu_tile](relu_tile.html#leaky-relu-tile)\\n  * [elu_tile](elu_tile.html)\\n  * [erf_tile](erf_tile.html)\\n  * [erfc_tile](erfc_tile.html)\\n  * [erfinv_tile](erfinv_tile.html)\\n  * [gelu_tile](gelu_tile.html)\\n  * [heaviside_tile](heaviside_tile.html)\\n  * [isinf_tile](isinf_tile.html)\\n  * [isposinf_tile](isinf_tile.html#isposinf-tile)\\n  * [isneginf_tile](isinf_tile.html#isneginf-tile)\\n  * [isfinite_tile](isinf_tile.html#isfinite-tile)\\n  * [isnan_tile](isnan_tile.html)\\n  * [i0_tile](i0_tile.html)\\n  * [logical_not_unary_tile](logical_not_unary_tile.html)\\n  * [recip_tile](recip_tile.html)\\n  * [sign_tile](sign_tile.html)\\n  * [sqrt_tile](sqrt_tile.html)\\n  * [rsqrt_tile](rsqrt_tile.html)\\n  * [sigmoid_tile](sigmoid_tile.html)\\n  * [log_tile](log_tile.html)\\n  * [log_with_base_tile](log_with_base_tile.html)\\n  * [power_tile](power_tile.html)\\n  * [rsub_tile](rsub_tile.html)\\n  * [signbit_tile](signbit_tile.html)\\n  * [square_tile](square_tile.html)\\n  * [reduce_tile](reduce_tile.html)\\n  * [transpose_wh_tile](transpose_wh_tile.html)\\n  * [tanh_tile](tanh_tile.html)\\n  * [tan_tile](tan_tile.html)\\n  * [sin_tile](sin_tile.html)\\n  * [cos_tile](cos_tile.html)\\n  * [asin_tile](asin_tile.html)\\n  * [atan_tile](atan_tile.html)\\n  * [acos_tile](acos_tile.html)\\n  * [ltz_tile](ltz_tile.html)\\n  * [eqz_tile](eqz_tile.html)\\n  * [lez_tile](lez_tile.html)\\n  * [gtz_tile](gtz_tile.html)\\n  * [gez_tile](gez_tile.html)\\n  * [nez_tile](nez_tile.html)\\n  * [unary_ne_tile](unary_ne_tile.html)\\n  * [unary_gt_tile](unary_gt_tile.html)\\n  * [unary_lt_tile](unary_lt_tile.html)\\n  * [cb_wait_front](cb_wait_front.html)\\n  * [cb_pop_front](cb_pop_front.html)\\n  * [cb_reserve_back](cb_reserve_back.html)\\n  * [cb_push_back](cb_push_back.html)\\n  * [binary_init_funcs](binary_op_init_funcs.html)\\n  * [tilize](tilize.html)\\n  * [untilize](untilize.html)\\n\\n#### atan_tile\\uf0c1\\n\\nvoid ckernel::atan_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::atan_tile(uint32_t idst)\\uf0c1      \\n\\nPerforms element-wise computation of arctan on each element of a tile in DST\\nregister at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True \\n\\n#### matmul_tiles\\uf0c1\\n\\nvoid ckernel::mm_init(uint32_t in0_cb_id, uint32_t in1_cb_id, uint32_t\\nout_cb_id, const uint32_t transpose = 0)\\uf0c1  \\n\\nInitialization for matmul_tiles operation. Must be called before matmul_tiles.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nout_cb_id  | The identifier of the output circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\ntranspose  | The transpose flag for performing transpose operation on B  | uint32_t  | Any positive value will indicate tranpose is set  | False   \\n  \\nvoid ckernel::mm_init_short_with_dt(uint32_t in0_cb_id, uint32_t in1_cb_id,\\nuint32_t c_in_old_srca, const uint32_t transpose = 0)\\uf0c1  \\n\\nA short version of matmul_tiles initialization. It is used to reconfigure srcA\\nof the compute engine back to matmul mode.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nc_in_old_srca  | The identifier of the old input to src A circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\ntranspose  | The transpose flag for performing transpose operation on B  | uint32_t  | Any positive value will indicate tranpose is set  | False   \\n  \\nvoid ckernel::mm_init_short(uint32_t in0_cb_id, uint32_t in1_cb_id, const\\nuint32_t transpose = 0)\\uf0c1  \\n\\nA short version of matmul_tiles initialization. Configure the unpacker and\\nmath engine to matmul mode.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\ntranspose  | The transpose flag for performing transpose operation on B  | uint32_t  | Any positive value will indicate tranpose is set  | False   \\n  \\nvoid ckernel::matmul_tiles(uint32_t in0_cb_id, uint32_t in1_cb_id, uint32_t\\nin0_tile_index, uint32_t in1_tile_index, uint32_t idst, const uint32_t\\ntranspose)\\uf0c1  \\n\\nPerforms tile-sized matrix multiplication _C=A*B_ between the tiles in two\\nspecified input CBs and writes the result to DST. The DST register buffer must\\nbe in acquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nin0_tile_index  | The index of the tile A from the first input CB  | uint32_t  | Must be less than the size of the CB  | True   \\nin1_tile_index  | The index of the tile B from the second input CB  | uint32_t  | Must be less than the size of the CB  | True   \\ndst_tile_index  | The index of the tile in DST REG to which the result C will be written.  | uint32_t  | Must be less than the acquired size of DST REG  | True \\n\\n#### copy_tile\\n\\nvoid ckernel::copy_tile(uint32_t in_cb_id, uint32_t in_tile_index, uint32_t\\ndst_tile_index)\\uf0c1  \\n\\nCopies a single tile from the specified input CB and writes the result to DST\\nat a specified index. The function will employ unpacker to first unpack into\\nSRC registers and then perform move into DST registers, at a specified index.\\nFor the in_tile_index to be valid for this call, cb_wait_front(n) had to be\\npreviously called to ensure that at least some number n>0 of tiles are\\navailable in the input CB. The CB index 0 then references the first tile in\\nthe received section of the CB, up to index n-1 (in a FIFO order). The DST\\nregister buffer must be in acquired state via acquire_dst call. This call is\\nblocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Data type  | Valid range  | required   \\n---|---|---|---|---  \\nin_cb_id  | The identifier of the source circular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nin_tile_index  | The index of the tile to copy from the input CB  | uint32_t  | Must be less than the size of the CB  | True   \\ndst_tile_index  | The index of the tile in the DST register  | uint32_t  | Must be less than the size of the DST register (16)  | True \\n\\n#### erfc_tile\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::erfc_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::erfc_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of complimentary error function on each\\nelement of a tile in DST register at index tile_index. The DST register buffer\\nmust be in acquired state via _acquire_dst_ call. This call is blocking and is\\nonly available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True \\n\\n#### unary_lt_tile\\uf0c1\\n\\nvoid ckernel::unary_lt_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::unary_lt_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of: result = 1 if x < value , where x is\\neach element of a tile in DST register at index tile_index. The value is\\nprovided as const param0 The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nparam0  | The value to be compared with the input tensor  | uint32_t  |  | True\\n\\n#### log_with_base_tile\\uf0c1\\n\\nvoid ckernel::log_with_base_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::log_with_base_tile(uint32_t idst, uint32_t base_scale)\\uf0c1  \\n\\nPerforms element-wise computation of logarithm with a specified base on each\\nelement of a tile in DST register at index tile_index. The DST register buffer\\nmust be in acquired state via _acquire_dst_ call. This call is blocking and is\\nonly available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nbase_scale  | The log base  | uint32_t  | Postive integers  | True\\n\\n#### mul_tiles_bcast\\uf0c1\\n\\nvoid ckernel::mul_bcast_cols_init_short(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nPerforms a first-call or switch-from-another-op tile hw reconfiguration step\\nneeded for mul_bcast_cols to be executed correctly.\\n\\nvoid ckernel::mul_bcast_rows_init_short(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nPerforms a switch-from-another-op tile hw reconfiguration step needed for\\nmul_bcast_rows to be executed correctly.\\n\\ntemplate<BroadcastType tBcastDim>  \\nvoid ckernel::mul_tiles_bcast(uint32_t icb0, uint32_t icb1, uint32_t itile0,\\nuint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nPlease refer to documentation for _add_tiles_bcast_.\\n\\nvoid ckernel::mul_tiles_bcast_scalar_init_short(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nPerforms a first-call or switch-from-another-op tile hw reconfiguration step\\nneeded for mul_bcast_cols to be executed correctly.\\n\\nvoid ckernel::mul_tiles_bcast_scalar(uint32_t icb0, uint32_t icb1, uint32_t\\nitile0, uint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nPerforms a broadcast-multiply of a tile from icb0[itile0] with a scalar\\nencoded as a tile from icb1[itile1].\\n\\n#### cos_tile\\uf0c1\\n\\nvoid ckernel::cos_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::cos_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the trigonometric cosine operation on\\neach element of a tile in DST register at index tile_index. The DST register\\nbuffer must be in acquired state via _acquire_dst_ call. This call is blocking\\nand is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### eqz_tile\\uf0c1\\n\\nvoid ckernel::eqz_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::eqz_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if each element of a equal\\nto zero. The DST register buffer must be in acquired state via _acquire_dst_\\ncall. This call is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### unary_gt_tile\\uf0c1\\n\\nvoid ckernel::unary_gt_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::unary_gt_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of: result = 1 if x > value , where x is\\neach element of a tile in DST register at index tile_index. The value is\\nprovided as const param0 The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nparam0  | The value to be compared with the input tensor  | uint32_t  |  | True\\n\\n#### mul_tiles\\uf0c1\\n\\nvoid ckernel::mul_tiles_init_f()\\uf0c1  \\n\\nPlease refer to documentation for any_init. f means high fidelity with\\nresepect to accuracy this is set during createprogram\\n\\nvoid ckernel::mul_tiles_init(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::mul_tiles(uint32_t icb0, uint32_t icb1, uint32_t itile0,\\nuint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise multiplication C=A*B of tiles in two CBs at given\\nindices and writes the result to the DST register at index dst_tile_index. The\\nDST register buffer must be in acquired state via _acquire_dst_ call. This\\ncall is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nin1_cb_id  | The identifier of the circular buffer (CB) containing B  | uint32_t  | 0 to 31  | True   \\nin0_tile_index  | The index of tile A within the first CB  | uint32_t  | Must be less than the size of the CB  | True   \\nin1_tile_index  | The index of tile B within the second CB  | uint32_t  | Must be less than the size of the CB  | True   \\ndst_tile_index  | The index of the tile in DST REG for the result C  | uint32_t  | Must be less than the acquired size of DST REG  | True\\n\\n#### nez_tile\\uf0c1\\n\\nvoid ckernel::nez_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::nez_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if each element is not equal\\nto zero. The DST register buffer must be in acquired state via _acquire_dst_\\ncall. This call is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### sign_tile\\uf0c1\\n\\nvoid ckernel::sign_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::sign_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core the signum of the tile. The DST\\nregister buffer must be in acquired state via _acquire_dst_ call. This call is\\nblocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### move_copy_tile\\uf0c1\\n\\nvoid ckernel::copy_tile_to_dst_init_short_with_dt(uint32_t old_cbid, uint32_t\\nnew_cbid, uint32_t transpose = 0)\\uf0c1  \\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nold_cbid  | The identifier of the previous input circular buffer (CB) to SrcA  | uint32_t  | 0 to 31  | True   \\nnew_cbid  | The identifier of the new input circular buffer (CB) to SrcA  | uint32_t  | 0 to 31  | True   \\ntranspose  | Flag to perform transpose on SrcA  | uint32_t  | Any positive value will indicate tranpose is set  | False   \\n  \\nvoid ckernel::copy_tile_to_dst_init_short(uint32_t cbid, uint32_t transpose =\\n0)\\uf0c1  \\n\\nPerform the init short for copy tile. This does not reconfigure the unpacker\\ndata types. Return value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ncbid  | The identifier of the input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\ntranspose  | Flag to perform transpose on SrcA  | uint32_t  | Any positive value will indicate tranpose is set  | False   \\n  \\nvoid ckernel::copy_tile_init(uint32_t cbid)\\uf0c1  \\n\\nPerform a init for the copy tile operation. This calls the short init function\\nand initializes packer dst offset registers.\\n#### transpose_wh_tile\\uf0c1\\n\\nvoid ckernel::transpose_wh_init(uint32_t icb, uint32_t ocb)\\uf0c1  \\n\\nPaired Init function for transpose_wh. For general information on init\\nfunctions refer to any_init.\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nicb  | The identifier of the circular buffer (CB) containing input  | uint32_t  | 0 to 31  | True   \\n  \\nvoid ckernel::transpose_wh_tile(uint32_t icb, uint32_t itile, uint32_t idst)\\uf0c1  \\n\\nPerforms a 32x32 transpose operation _B[w,h] = A[h,w]_ on a tile in the CB at\\na given index and writes the result to the DST register at index\\ndst_tile_index. The DST register buffer must be in acquired state via\\n_acquire_dst_ call.\\n\\nThis call is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin_cb_id  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nin_tile_index  | The index of tile A within the first CB  | uint32_t  | Must be less than the size of the CB  | True   \\ndst_tile_index  | The index of the tile in DST REG for the result B  | uint32_t  | Must be less than the acquired size of DST REG  | True\\n\\n#### elu_tile\\uf0c1\\n\\nvoid ckernel::elu_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::elu_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of elu (relu(x) + slope*(exp(x) - 1)*(x <= 0\\n)) on each element of a tile in DST register at index tile_index. The DST\\nregister buffer must be in acquired state via _acquire_dst_ call. This call is\\nblocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nslope  | slope used in elu calculation  | uint32_t  | Greater than 0  | True\\n\\n#### isinf_tile\\uf0c1\\n\\nvoid ckernel::isinf_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::isinf_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if the input tile is\\ninfinity. The DST register buffer must be in acquired state via _acquire_dst_\\ncall. This call is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\n  \\n# isposinf_tile\\uf0c1\\n\\nvoid ckernel::isposinf_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::isposinf_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if the input tile is\\npositive infinity. The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\n  \\n# isneginf_tile\\uf0c1\\n\\nvoid ckernel::isneginf_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::isneginf_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if the input tile is\\nnegative infinity. The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\n  \\n# isfinite_tile\\uf0c1\\n\\nvoid ckernel::isfinite_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::isfinite_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if the input tile is finite\\nThe DST register buffer must be in acquired state via _acquire_dst_ call. This\\ncall is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### relu_tile\\uf0c1\\n\\nvoid ckernel::relu_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::relu_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of relu (0 if negative else 1) on each\\nelement of a tile in DST register at index tile_index. The DST register buffer\\nmust be in acquired state via _acquire_dst_ call. This call is blocking and is\\nonly available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\n  \\n# relu_max_tile\\uf0c1\\n\\nvoid ckernel::relu_max_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::relu_max_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of relu max (relu(max(x, upper_limit))) on\\neach element of a tile in DST register at index tile_index. The DST register\\nbuffer must be in acquired state via _acquire_dst_ call. This call is blocking\\nand is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nupper_limit  | Upper limit of relu_min  | uint32_t  | Greater than 0  | True   \\n  \\n# relu_min_tile\\uf0c1\\n\\nvoid ckernel::relu_min_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::relu_min_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of relu min (relu(min(x, lower_limit))) on\\neach element of a tile in DST register at index tile_index. The DST register\\nbuffer must be in acquired state via _acquire_dst_ call. This call is blocking\\nand is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nlower_limit  | Upper limit of relu_min  | uint32_t  | Greater than 0  | True   \\n  \\n# leaky_relu_tile\\uf0c1\\n\\nvoid ckernel::leaky_relu_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::leaky_relu_tile(uint32_t idst, uint32_t slope)\\uf0c1  \\n\\nPerforms element-wise computation of leaky relu (relu(x) + slope*-relu(-x)) on\\neach element of a tile in DST register at index tile_index. The DST register\\nbuffer must be in acquired state via _acquire_dst_ call. This call is blocking\\nand is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nslope  | slope used in leaky relu - will reinterpret unsigned int to float  | uint32_t  | Greater than 0  | True\\n\\n#### untilize\\uf0c1\\n\\nvoid ckernel::untilize_init(uint32_t icb, uint32_t ocb)\\uf0c1  \\n\\nInit function for untilize operations, to be used at the beginning of the\\nkernel.\\n\\nvoid ckernel::untilize_init_short(uint32_t icb)\\uf0c1  \\n\\nShort init function to initialize untilize op, after a full init is already\\nperformed.\\n\\ntemplate<int N = 1>  \\nvoid ckernel::untilize_block(uint32_t icb, uint32_t block, uint32_t ocb)\\uf0c1  \\n\\nPerform the untilize operation on a block of tiles. This simply loops over the\\nprovided block size.\\n\\nvoid ckernel::untilize_uninit(uint32_t icb)\\uf0c1  \\n\\nUninitialize untilize operation, to allow initializing another operation.\\n\\n#### gtz_tile\\uf0c1\\n\\nvoid ckernel::gtz_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::gtz_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if each element is greater\\nthan zero. The DST register buffer must be in acquired state via _acquire_dst_\\ncall. This call is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### power_tile\\uf0c1\\n\\nvoid ckernel::power_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::power_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of power operation (x ^(const param0)) value\\non each element of a tile in DST register at index tile_index. The DST\\nregister buffer must be in acquired state via _acquire_dst_ call. This call is\\nblocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nparam0  | The value of the exponent in the power operation  | uint32_t  |  | True\\n\\n#### logical_not_unary_tile\\uf0c1\\n\\nvoid ckernel::logical_not_unary_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::logical_not_unary_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the logical not unary operation on each\\nelement of a tile in DST register at index tile_index. The DST register buffer\\nmust be in acquired state via _acquire_dst_ call. This call is blocking and is\\nonly available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### heaviside_tile\\uf0c1\\n\\nvoid ckernel::heaviside_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::heaviside_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of: y = 0 if x < 0 , 1 if x > 0 , y= value\\nwhere x is each element of a tile in DST register at index tile_index. The\\nvalue is provided as const param0 The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nparam0  | The value the output is if the input is greater than 0  | uint32_t  |  | True\\n\\n#### acos_tile\\uf0c1\\n\\nvoid ckernel::acos_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::acos_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of arccossine on each element of a tile in\\nDST register at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### add_tiles_bcast\\uf0c1\\n\\nvoid ckernel::add_bcast_cols_init_short(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nPerforms a first-call or switch-from-another-op tile hw reconfiguration step\\nneeded for add_bcast_cols to be executed correctly. Required to be called\\nbefore add_tiles_bcast if using column as broadcast type\\n\\nvoid ckernel::add_bcast_rows_init_short(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nPerforms a first-call or switch-from-another-op tile hw reconfiguration step\\nneeded for add_bcast_rows to be executed correctly. Required to be called\\nbefore add_tiles_bcast if using column as broadcast type\\n\\ntemplate<BroadcastType tBcastDim>  \\nvoid ckernel::add_tiles_bcast(uint32_t icb0, uint32_t icb1, uint32_t itile0,\\nuint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nThis documentation applies to either one of the 3 broadcast operation variants\\n- _add_tiles_bcast_ , _sub_tiles_bcast_ and _mul_tiles_bcast_.\\n\\nThe description below describes _add_tiles_bcast_ , the other 2 operations use\\nthe same definition with the corresponding substitution of the math operator.\\n\\nPerforms a broadcast-operation _C=A+B_ of tiles in two CBs at given indices\\nand writes the result to the DST register at index dst_tile_index. The DST\\nregister buffer must be in acquired state via _acquire_dst_ call. This call is\\nblocking and is only available on the compute engine.\\n\\nBroadcasting semantics are defined as follows:\\n\\nFor _dim==BroadcastType::COL_ , the input in _B_ is expected to be a single\\ntile with a filled 0-column and zeros elsewhere. The result is _C[h, w] =\\nA[h,w] + B[w]_\\n\\nFor _dim==Dim::C_ , the input in _B_ is expected to be a single tile with a\\nfilled 0-row, and zeros elsewhere. The result is _C[h, w] = A[h,w] + B[h]_\\n\\nFor _dim==Dim::RC_ , the input in _B_ is expected to be a single tile with a\\nfilled single value at location [0,0], and zeros elsewhere. The result is\\n_C[h, w] = A[h,w] + B[0,0]_\\n\\nReturn value: None\\n\\nDOX-TODO(AP): verify that the bcast tile is actually required to be filled\\nwith zeros.\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntBcastDim  | Broadcast dimension  | BroadcastType  | One of Dim::R, Dim::C, Dim::RC.  | True   \\nin0_cb_id  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nin1_cb_id  | The indentifier of the circular buffer (CB) containing B  | uint32_t  | 0 to 31  | True   \\nin0_tile_index  | The index of tile A within the first CB  | uint32_t  | Must be less than the size of the CB  | True   \\nin1_tile_index  | The index of tile B within the second CB  | uint32_t  | Must be less than the size of the CB  | True   \\ndst_tile_index  | The index of the tile in DST REG for the result C  | uint32_t  | Must be less than the acquired size of DST REG  | True\\n\\n#### tan_tile\\uf0c1\\n\\nvoid ckernel::tan_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::tan_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the trigonometric tan operation on each\\nelement of a tile in DST register at index tile_index. The DST register buffer\\nmust be in acquired state via _acquire_dst_ call. This call is blocking and is\\nonly available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### ltz_tile\\uf0c1\\n\\nvoid ckernel::ltz_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::ltz_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if each element of a tile is\\nless than zero. The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### release_dst\\uf0c1\\n\\nvoid ckernel::release_dst()\\uf0c1  \\n\\n_Deprecated:_\\n\\nThis function is deprecated, please use\\n`[tile_regs_release()](reg_api.html#namespaceckernel_1addd3679665da343bd51f76ced7154c4a)`\\ninstead. See <https://github.com/tenstorrent/tt-\\nmetal/issues/5868#issuecomment-2101726935>\\n\\nReleases the exclusive lock on the internal DST register for the current\\nTensix core. This lock had to be previously acquired with acquire_dst. This\\ncall is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nHow the destination register will be shared and synchronized between TRISC\\nthreads will depend on the compute kernel configuration.\\n#### unary_ne_tile\\uf0c1\\n\\nvoid ckernel::unary_ne_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::unary_ne_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of: result = 1 if x!=value , where x is each\\nelement of a tile in DST register at index tile_index. The value is provided\\nas const param0 The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nparam0  | The value to be compared with the input tensor  | uint32_t  |  | True\\n\\n#### sub_tiles_bcast\\uf0c1\\n\\nvoid ckernel::sub_bcast_cols_init_short(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nPerforms a first-call or switch-from-another-op tile hw reconfiguration step\\nneeded for sub_bcast_cols to be executed correctly.\\n\\ntemplate<BroadcastType tBcastDim>  \\nvoid ckernel::sub_tiles_bcast(uint32_t icb0, uint32_t icb1, uint32_t itile0,\\nuint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nPlease refer to documentation for _add_tiles_bcast_.\\n#### gelu_tile\\uf0c1\\n\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::gelu_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::gelu_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of gelu on each element of a tile in DST\\nregister at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nfast_and_approx  | Computation to be done faster and approximate  | bool  |  | False\\n\\n#### matmul_block\\uf0c1\\n\\nvoid ckernel::mm_block_init(uint32_t in0_cb_id, uint32_t in1_cb_id, uint32_t\\nout_cb_id, const uint32_t transpose = 0, uint32_t ct_dim = 1, uint32_t rt_dim\\n= 1, uint32_t kt_dim = 1)\\uf0c1  \\n\\nInitialization for matmul_block operation. Must be called before matmul_block.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nout_cb_id  | The identifier of the output circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nct_dim  | The number of columns of the output matrix in tiles  | uint32_t  | 1 to 8 in half-sync mode, 1 to 16 in full-sync mode  | False   \\nrt_dim  | The number of rows of the output matrix in tiles  | uint32_t  | 1 to 8 in half-sync mode, 1 to 16 in full-sync mode  | False   \\nkt_dim  | The inner dim of the input matrices in tiles  | uint32_t  | 1 to 2^32-1  | False   \\n  \\nvoid ckernel::mm_block_init_short(uint32_t in0_cb_id, uint32_t in1_cb_id,\\nconst uint32_t transpose = 0, uint32_t ct_dim = 1, uint32_t rt_dim = 1,\\nuint32_t kt_dim = 1)\\uf0c1  \\n\\nA short version of matmul_block initialization. Configure the unpacker and\\nmath engine to matmul mode.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\ntranspose  | The transpose flag for performing transpose operation on B  | uint32_t  | Any positive value will indicate tranpose is set  | False   \\nct_dim  | The coloumn dimension for the output block.  | uint32_t  | Must be equal to block B column dimension  | False   \\nrt_dim  | The row dimension for the output block.  | uint32_t  | Must be equal to block A row dimension  | False   \\nkt_dim  | The inner dimension.  | uint32_t  | Must be equal to block A column dimension  | False   \\n  \\nvoid ckernel::mm_block_init_short_with_dt(uint32_t in0_cb_id, uint32_t\\nin1_cb_id, uint32_t old_in1_cb_id, const uint32_t transpose = 0, uint32_t\\nct_dim = 1, uint32_t rt_dim = 1, uint32_t kt_dim = 1)\\uf0c1  \\n\\nA short version of matmul_block initialization. It is used to reconfigure srcA\\nof the compute engine back to matmul mode.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nold_in1_cb_id  | The identifier of the old in1_cb_id circular buffer (CB)  | uint32_t  | 0 to 31  | False   \\nct_dim  | The coloumn dimension for the output block.  | uint32_t  | Must be equal to block B column dimension  | False   \\nrt_dim  | The row dimension for the output block.  | uint32_t  | Must be equal to block A row dimension  | False   \\nkt_dim  | The inner dimension.  | uint32_t  | Must be equal to block A column dimension  | False   \\n  \\nvoid ckernel::matmul_block(uint32_t in0_cb_id, uint32_t in1_cb_id, uint32_t\\nin0_tile_index, uint32_t in1_tile_index, uint32_t idst, const uint32_t\\ntranspose, uint32_t ct_dim, uint32_t rt_dim, uint32_t kt_dim)\\uf0c1  \\n\\nPerforms block-sized matrix multiplication _C=A*B_ between the blocks in two\\ndifferent input CBs and writes the result to DST. The DST register buffer must\\nbe in acquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the first input circular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nin1_cb_id  | The identifier of the second input circular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nin0_tile_index  | The index of the tile in block A from the first input CB  | uint32_t  | Must be less than the size of the CB  | True   \\nin1_tile_index  | The index of the tile in block B from the second input CB  | uint32_t  | Must be less than the size of the CB  | True   \\nidst  | The index of the tile in DST REG to which the result C will be written.  | uint32_t  | Must be less than the acquired size of DST REG  | True   \\ntranspose  | The transpose flag for performing transpose operation on tiles in B.  | bool  | Must be true or false  | True   \\nct_dim  | The coloumn dimension for the output block.  | uint32_t  | Must be equal to block B column dimension  | True   \\nrt_dim  | The row dimension for the output block.  | uint32_t  | Must be equal to block A row dimension  | True   \\nkt_dim  | The inner dimension.  | uint32_t  | Must be equal to block A column dimension  | True\\n\\n#### lez_tile\\uf0c1\\n\\nvoid ckernel::lez_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::lez_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if each element is less than\\nor equal to zero. The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### reg_api\\uf0c1\\n\\nvoid ckernel::tile_regs_acquire()\\uf0c1  \\n\\nAcquire an exclusive lock on the DST register for the MATH thread. This\\nregister is an array of 16 tiles of 32x32 elements each. This is a blocking\\nfunction, i.e. this function will wait until the lock is acquired.\\n\\nvoid ckernel::tile_regs_wait()\\uf0c1  \\n\\nAcquire an exclusive lock on the DST register for the PACK thread. It waits\\nfor the MATH thread to commit the DST register. This is a blocking function,\\ni.e. this function will wait until the lock is acquired.\\n\\nvoid ckernel::tile_regs_commit()\\uf0c1  \\n\\nRelease lock on DST register by MATH thread. The lock had to be previously\\nacquired with tile_regs_acquire.\\n\\nvoid ckernel::tile_regs_release()\\uf0c1  \\n\\nRelease lock on DST register by PACK thread. The lock had to be previously\\nacquired with tile_regs_wait.\\n#### tanh_tile\\uf0c1\\n\\nvoid ckernel::tanh_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::tanh_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of tanh on each element of a tile in DST\\nregister at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### sin_tile\\uf0c1\\n\\nvoid ckernel::sin_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::sin_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the trigonometric sine operation on each\\nelement of a tile in DST register at index tile_index. The DST register buffer\\nmust be in acquired state via _acquire_dst_ call. This call is blocking and is\\nonly available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### log_tile\\uf0c1\\n\\nvoid ckernel::log_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::log_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of logarithm on each element of a tile in\\nDST register at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### gez_tile\\uf0c1\\n\\nvoid ckernel::gez_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::gez_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if each element is greater\\nthan or equal to zero. The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### cb_reserve_back\\uf0c1\\n\\nvoid ckernel::cb_reserve_back(uint32_t cbid, uint32_t ntiles)\\uf0c1  \\n\\nA blocking call that waits for the specified number of tiles to be free in the\\nspecified circular buffer. This call is used by the producer to wait for the\\nconsumer to consume (ie. free up) the specified number of tiles.\\n\\nCB total size must be an even multiple of the argument passed to this call.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ncb_id  | The index of the cirular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nntiles  | The number of free tiles to wait for  | uint32_t  | It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)  | True\\n\\n#### sqrt_tile\\uf0c1\\n\\nvoid ckernel::sqrt_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::sqrt_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the square root on each element of a tile\\nin DST register at index tile_index. The DST register buffer must be in\\nacquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### add_tiles\\uf0c1\\n\\nvoid ckernel::add_tiles_init_nof()\\uf0c1  \\n\\nPlease refer to documentation for any_init. nof means low fidelity with\\nresepect to accuracy this is set during createprogram\\n\\nvoid ckernel::add_tiles_init(uint32_t icb0, uint32_t icb1, bool acc_to_dest =\\nfalse)\\uf0c1  \\n\\nShort init function\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nicb0  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nicb1  | The identifier of the circular buffer (CB) containing B  | uint32_t  | 0 to 31  | True   \\nacc_to_dest  | If true, operation = A + B + dst_tile_idx of add_tiles  | bool  | 0,1  | False   \\n  \\nvoid ckernel::add_tiles(uint32_t icb0, uint32_t icb1, uint32_t itile0,\\nuint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise addition C=A+B of tiles in two CBs at given indices and\\nwrites the result to the DST register at index dst_tile_index. The DST\\nregister buffer must be in acquired state via _acquire_dst_ call. This call is\\nblocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nin1_cb_id  | The identifier of the circular buffer (CB) containing B  | uint32_t  | 0 to 31  | True   \\nin0_tile_index  | The index of tile A within the first CB  | uint32_t  | Must be less than the size of the CB  | True   \\nin1_tile_index  | The index of tile B within the second CB  | uint32_t  | Must be less than the size of the CB  | True   \\ndst_tile_index  | The index of the tile in DST REG for the result C  | uint32_t  | Must be less than the acquired size of DST REG  | True\\n\\n#### recip_tile\\uf0c1\\n\\nvoid ckernel::recip_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::recip_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the reciprocal on each element of a tile\\nin DST register at index tile_index. The DST register buffer must be in\\nacquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine. Only works for Float32, Float16_b, Bfp8_b\\ndata formats for full accuracy.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### signbit_tile\\uf0c1\\n\\nvoid ckernel::signbit_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::signbit_tile(uint32_t idst)\\uf0c1  \\n\\nSets the sign bit of each element of a tile in DST register at index\\ntile_index. The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to modify the sign bit of  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### sigmoid_tile\\uf0c1\\n\\nvoid ckernel::sigmoid_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::sigmoid_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of sigmoid on each element of a tile in DST\\nregister at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### tilize\\uf0c1\\n\\nvoid ckernel::tilize_init(uint32_t icb, uint32_t block, uint32_t ocb)\\uf0c1  \\n\\nInitialize the tilize operation. To be called once at beginning of a kernel.\\n\\nvoid ckernel::tilize_init_short(uint32_t icb, uint32_t block, uint32_t ocb)\\uf0c1  \\n\\nRe-initialize for the tilize operation. This can be called after a full init.\\n\\nvoid ckernel::tilize_init_short_with_dt(uint32_t old_icb, uint32_t new_icb,\\nuint32_t block, uint32_t ocb)\\uf0c1  \\n\\nRe-initialize for the tilize operation. This also reconfigure the unpacker\\nwith CB data type.\\n\\nvoid ckernel::tilize_block(uint32_t icb, uint32_t block, uint32_t ocb)\\uf0c1  \\n\\nPerform tilize operation on a block. This simply loops over the provided\\nblocks.\\n\\nvoid ckernel::tilize_uninit(uint32_t icb, uint32_t ocb)\\uf0c1  \\n\\nUninitialize tilize operation before re-initializing for another operation.\\n\\nvoid ckernel::tilize_uninit_with_dt(uint32_t old_icb, uint32_t new_icb,\\nuint32_t ocb)\\uf0c1  \\n\\nUninitialize the tilize operation along with re-configuring unpacker with the\\nCB data types.\\n#### erf_tile\\uf0c1\\n\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::erf_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::erf_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of error function on each element of a tile\\nin DST register at index tile_index. The DST register buffer must be in\\nacquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### rsub_tile\\uf0c1\\n\\nvoid ckernel::rsub_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::rsub_tile(uint32_t idst, uint32_t param0)\\uf0c1  \\n\\nPerforms element-wise computation of rsub ( rsub(x,y) = y -x) on each element\\nof a tile and y is a constant param in DST register at index tile_index. The\\nDST register buffer must be in acquired state via _acquire_dst_ call. This\\ncall is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nparam0  | Constant value that is being subtracted from  | uint32_t  |  | True\\n\\n#### cb_wait_front\\uf0c1\\n\\nvoid ckernel::cb_wait_front(uint32_t cbid, uint32_t ntiles)\\uf0c1  \\n\\nA blocking call that waits for the specified number of tiles to be available\\nin the specified circular buffer (CB). This call is used by the consumer of\\nthe CB to wait for the producer to fill the CB with at least the specfied\\nnumber of tiles. Important note: in case multiple calls of cb_wait_front(n)\\nare issued without a paired\\n[cb_pop_front()](cb_pop_front.html#namespaceckernel_1a09e8d82ba4b886f8e90eec038735d759)\\ncall, n is expected to be incremented by the user to be equal to a cumulative\\ntotal of tiles. Example: 4 calls of cb_wait_front(8) followed by a\\ncb_pop_front(32) would produce incorrect behavior. Instead 4 calls of\\ncb_wait_front() waiting on 8, 16, 24, 32 tiles should be issued.\\n\\nImportant note: number of tiles used in all cb_* calls must evenly divide the\\ncb size and must be the same number in all cb_wait_front calls in the same\\nkernel. Example 1: cb_wait_front(32), cb_wait_front(40), cb_pop_front(32+8)\\ntiles on a CB of size 64 would produce incorrect behavior. Example 2:\\ncb_wait_front(3) on a cb of size 32 would also produce incorrect behavior.\\nThese limitations are due to performance optimizations in the CB\\nimplementation.\\n\\nImportant note: CB total size must be an even multiple of the argument passed\\nto this call.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ncb_id  | The index of the cirular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nntiles  | The number of tiles to wait for  | uint32_t  | It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)  | True\\n\\n#### i0_tile\\uf0c1\\n\\nvoid ckernel::i0_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::i0_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the zeroth order modified Bessel function\\nof the first kind on each element of a tile in DST register at index\\ntile_index. The DST register buffer must be in acquired state via\\n_acquire_dst_ call. This call is blocking and is only available on the compute\\nengine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### cb_push_back\\uf0c1\\n\\nvoid ckernel::cb_push_back(uint32_t cbid, uint32_t ntiles)\\uf0c1  \\n\\nPushes a given number of tiles in the back of the specified CB\\u2019s queue.\\nDecreases the available space in the circular buffer by this number of tiles.\\nThis call is used by the producer to make the tiles visible to the consumer of\\nthe CB.\\n\\nWe use the convention that the producer pushes tiles into the \\u201cback\\u201d of the CB\\nqueue and the consumer consumes tiles from the \\u201cfront\\u201d of the CB queue.\\n\\nNote that the act of writing the tile data into the CB does not make the tiles\\nvisible to the consumer. Writing of the tiles and pushing is separated to\\nallow the producer to: 1) write the tile data to the CB via multiple writes of\\nsub-tiles 2) modify tiles (or sub-tiles) by random access of the valid section\\nof the CB\\n\\nImportant note: This operation updates the write pointer of the CB, the CB\\npointer can only be updated from one thread at a time. Example: if compute\\nkernel has cb_push_back(output_id, 1) and reader kernel also has\\ncb_push_back(output_id, 1), these calls will produce non-deterministic\\nbehavior because cb pointers are not synchronized across threads. Per circular\\nbuffer index, only have one thread push tiles to update the write pointer\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ncb_id  | The index of the cirular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nntiles  | The number of tiles to be pushed  | uint32_t  | It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)  | True\\n\\n#### cb_pop_front\\uf0c1\\n\\nvoid ckernel::cb_pop_front(uint32_t cbid, uint32_t ntiles)\\uf0c1  \\n\\nPops a specified number of tiles from the front of the specified CB. This also\\nfrees this number of tiles in the circular buffer. This call is used by the\\nconsumer to free up the space in the CB.\\n\\nWe use the convention that the producer pushes tiles into the \\u201cback\\u201d of the CB\\nqueue and the consumer consumes tiles from the \\u201cfront\\u201d of the CB queue.\\n\\nNote that the act of reading of the tile data from the CB does not free up the\\nspace in the CB. Waiting on available tiles and popping them is separated in\\norder to allow the consumer to: 1) read the tile data from the CB via multiple\\nreads of sub-tiles 2) access the tiles (or their sub-tiles) that are visible\\nto the consumer by random access of the valid section of the CB\\n\\nImportant note: This operation updates the read pointer of the CB, the CB\\npointer can only be updated from one thread at a time. Example: if compute\\nkernel has cb_pop_front(input_id, 1) and writer kernel also has\\ncb_pop_front(input_id, 1), these calls will produce non-deterministic behavior\\nbecause cb pointers are not synchronized across threads. Per circular buffer\\nindex, only have one thread pop tiles to update the read pointer\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ncb_id  | The index of the cirular buffer (CB)  | uint32_t  | 0 to 31  | True   \\nntiles  | The number of tiles to be popped  | uint32_t  | It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)  | True\\n\\n#### erfinv_tile\\uf0c1\\n\\nvoid ckernel::erfinv_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::erfinv_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of the inverse of the error function on each\\nelement of a tile in DST register at index tile_index. The DST register buffer\\nmust be in acquired state via _acquire_dst_ call. This call is blocking and is\\nonly available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### reduce_tile\\uf0c1\\n\\ntemplate<PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM>  \\nvoid ckernel::reduce_tile(uint32_t icb0, uint32_t icb1, uint32_t itile0,\\nuint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nPerforms a reduction operation _B = reduce(A)_ using reduce_func for dimension\\nreduction on a tile in the CB at a given index and writes the result to the\\nDST register at index _dst_tile_index_. Reduction can be either of type\\n_Reduce::R_ , _Reduce::C_ or _Reduce::RC_ , identifying the dimension(s) to be\\nreduced in size to 1. The DST register buffer must be in acquired state via\\n_acquire_dst_ call.\\n\\nThe templates takes reduce_type which can be ReduceFunc::Sum, ReduceFunc::Max\\nand reduce_dim which can be Reduce::R, Reduce::C, Reduce::RC. They can also be\\nspecified by defines REDUCE_OP and REDUCE_DIM.\\n\\nThis call is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nicb0  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nicb1  | CB for Scaling factor applied to each element of the result.  | uint32_t  | 0 to 31  | True   \\nitile0  | The index of the tile within the first CB  | uint32_t  | Must be less than the size of the CB  | True   \\nitile1  | The index of the tile within the scaling factor CB.  | uint32_t  | Must be less than the size of the CB  | True   \\nidst  | The index of the tile in DST REG for the result  | uint32_t  | Must be less than the acquired size of DST REG  | True\\n\\n#### isnan_tile\\uf0c1\\n\\nvoid ckernel::isnan_tile(uint32_t idst)\\uf0c1  \\n\\nWill store in the output of the compute core True if the input tile is nan.\\nThe DST register buffer must be in acquired state via _acquire_dst_ call. This\\ncall is blocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### rsqrt_tile\\uf0c1\\n\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::rsqrt_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\ntemplate<bool fast_and_approx = true>  \\nvoid ckernel::rsqrt_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of reciprocal sqrt on each element of a tile\\nin DST register at index tile_index. The DST register buffer must be in\\nacquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nfast_and_approx  | Computation to be done faster and approximate  | bool  |  | False\\n\\n#### asin_tile\\uf0c1\\n\\nvoid ckernel::asin_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::asin_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of arcsine on each element of a tile in DST\\nregister at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### square_tile\\uf0c1\\n\\nvoid ckernel::square_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::square_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of square value on each element of a tile in\\nDST register at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### sub_tiles\\uf0c1\\n\\nvoid ckernel::sub_tiles_init_nof()\\uf0c1  \\n\\nPlease refer to documentation for any_init. nof means low fidelity with\\nrespect to accuracy this is set during createprogram\\n\\nvoid ckernel::sub_tiles_init(uint32_t icb0, uint32_t icb1, bool acc_to_dest =\\nfalse)\\uf0c1  \\n\\nShort init function\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nicb0  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nicb1  | The identifier of the circular buffer (CB) containing B  | uint32_t  | 0 to 31  | True   \\nacc_to_dest  | If true, operation = A - B + dst_tile_idx of sub_tiles  | bool  | 0,1  | False   \\n  \\nvoid ckernel::sub_tiles(uint32_t icb0, uint32_t icb1, uint32_t itile0,\\nuint32_t itile1, uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise subtraction C=A-B of tiles in two CBs at given indices\\nand writes the result to the DST register at index dst_tile_index. The DST\\nregister buffer must be in acquired state via _acquire_dst_ call. This call is\\nblocking and is only available on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nin0_cb_id  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nin1_cb_id  | The identifier of the circular buffer (CB) containing B  | uint32_t  | 0 to 31  | True   \\nin0_tile_index  | The index of tile A within the first CB  | uint32_t  | Must be less than the size of the CB  | True   \\nin1_tile_index  | The index of tile B within the second CB  | uint32_t  | Must be less than the size of the CB  | True   \\ndst_tile_index  | The index of the tile in DST REG for the result C  | uint32_t  | Must be less than the acquired size of DST REG  | True\\n\\n#### binary_init_funcs\\uf0c1\\n\\nvoid ckernel::binary_op_init_common(uint32_t icb0, uint32_t icb1, uint32_t\\nocb)\\uf0c1  \\n\\nInit function for all binary ops Followed by the specific init required with\\nan opcode (binrary_op_specific_init)\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nicb0  | The identifier of the circular buffer (CB) containing A  | uint32_t  | 0 to 31  | True   \\nicb1  | The identifier of the circular buffer (CB) containing B  | uint32_t  | 0 to 31  | True   \\nocb  | The identifier of the circular buffer (CB) containing output  | uint32_t  | 0 to 31, defaults to CB 16  | True   \\n  \\ntemplate<bool full_init = false, EltwiseBinaryType eltwise_binary_op_type =\\nELWADD>  \\nvoid ckernel::binary_op_specific_init(uint32_t icb0, uint32_t icb1)\\uf0c1  \\n\\nInit function with a specified op template parameters: full_init: if true, the\\nfull init is performed (unpack+math), otherwise a nof init is performed (only\\nmath) eltwise_binary_op_type: the binary operation type\\n#### exp2_tile\\uf0c1\\n\\nvoid ckernel::exp2_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::exp2_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of 2^x value where x is each element of a\\ntile in DST register at index tile_index. The DST register buffer must be in\\nacquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### expm1_tile\\uf0c1\\n\\nvoid ckernel::expm1_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::expm1_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of exp(x) - 1, v where x is each element of\\na tile in DST register at index tile_index. The DST register buffer must be in\\nacquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True\\n\\n#### acquire_dst\\uf0c1\\n\\nvoid ckernel::acquire_dst()\\uf0c1  \\n\\n_Deprecated:_\\n\\nThis function is deprecated, please use\\n`[tile_regs_acquire()](reg_api.html#namespaceckernel_1a34467f46da4221ff3a2820ff1baec122)`\\ninstead. See <https://github.com/tenstorrent/tt-metal/issues/5868#issuecomment-2101726935>\\n\\nAcquires an exclusive lock on the internal DST register for the current Tensix\\ncore.\\n\\nThis register is an array of 16 tiles of 32x32 elements each. This is a\\nblocking function, i.e. this function will wait until the lock is acquired.\\n\\nThis is only available on the compute engine.\\n\\nReturn value: None\\n\\nHow the destination register will be shared and synchronized between TRISC\\nthreads will depend on the compute kernel configuration.\\n#### exp_tile\\uf0c1\\n\\ntemplate<bool fast_and_approx = false>  \\nvoid ckernel::exp_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\ntemplate<bool fast_and_approx = false>  \\nvoid ckernel::exp_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of exponential on each element of a tile in\\nDST register at index tile_index. The DST register buffer must be in acquired\\nstate via _acquire_dst_ call. This call is blocking and is only available on\\nthe compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\ntile_index  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True   \\nfast_and_approx  | Computation to be done faster and approximate  | bool  |  | False\\n\\n#### any_init\\uf0c1\\n\\nMost compute API calls have an *_init paired API call (for example\\nexp_tile_init and exp_tile). Invoking this *_init API configures the compute\\nunit for execution of the subsequent paired call.\\n#### abs_tile\\uf0c1\\n\\nvoid ckernel::abs_tile_init()\\uf0c1  \\n\\nPlease refer to documentation for any_init.\\n\\nvoid ckernel::abs_tile(uint32_t idst)\\uf0c1  \\n\\nPerforms element-wise computation of absolute value on each element of a tile\\nin DST register at index tile_index. The DST register buffer must be in\\nacquired state via _acquire_dst_ call. This call is blocking and is only\\navailable on the compute engine.\\n\\nReturn value: None\\n\\nArgument  | Description  | Type  | Valid Range  | Required   \\n---|---|---|---|---  \\nidst  | The index of the tile in DST register buffer to perform the computation on  | uint32_t  | Must be less than the size of the DST register buffer  | True \"\n    }\n  ]\n}"
    }
  ],
  "max_tokens": 10000,
  "timestamp": "2025-07-03T03:47:15.944743"
}